https://projecteuler.net/problem=2 `Even Fibonacci numbers`

> Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:
> 
> 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
> 
> By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.

<details>
<summary>Answer:</summary>
4613732 
</details>

W tym zadaniu chodzi o liczby Fibonacciego

https://pl.wikipedia.org/wiki/Ciąg_Fibonacciego

Tak na prawdę to ciąg ten zaczyna się od 0,1,1,2,3,58... a nie 1,2,3,5,8... no ale tak przyjęli w zadaniu.

Trzeba więc policzyć sumę tych liczb, ale tylko parzystych i tylko jeśli liczba nie przekracza 4 miliony.

Tutaj mała dygresja, nie wiem czy się przyda przy dalszych zadaniach, bo dawno temu je robiłem, ale jeśli chodzi o treść słowną, to tysiące i miliony anglosaskie się zgadzają z naszymi, ale większe liczby już nie. 

https://pl.wikipedia.org/wiki/Liczebniki_główne_potęg_tysiąca#Nazwy_utrwalone_w_piśmiennictwie

Także nasz miliard nie ma odpowiednia w anglosaskim, a bilion u nas to jedynka i dwanaście zer, a u nich jedynka i dziewięć zer.

No to jak niezbędną teorię mamy za sobą, to jedziemy z kodem. 

Tu będzie mały spoiler, w prawdzie jeszcze kodu nie napisałem, ale już mogę powiedzieć, że generowanie liczb Fibonacciego można zrobić zwyczajnie pętlą (iteracyjnie) lub rekurencyjnie. 

Można też użyć techniki bardziej zaawansowanej w Pythonie i użyć generatora, ale wszystko w swoim czasie. 

Tu chodzi o to by się zapoznać z językiem, więc zrobię metodę najprostszą "jakem polski chop". 

A w ramach zadania domowego ktoś może napisać wersję z generatorem oraz rekurencyjną (nie jest trudna), trzeba jednak pamiętać, że można tak wygenerować około tysiąca liczb, bo poziomów zagnieżdżenia rekurencyjnego w Pythonie jest chyba równy tysiąc jak dobrze pamiętam.

Zacznę od tej trudniejszej sprawy, czyli generowanie liczb. Wyjdę od prostej pętli sumującej liczby z limitem maksymalnym wartości:

```python
def fibonacci(max_value):
    sum = 0
    i = 1
    while True:
        if i > max_value:
            break
        sum = sum + i  # lub krócej "sum += i"
        i = i + 1
    return sum

print(fibonacci(3))
print(fibonacci(10))
```
```
6
55
```
sprawdźmy na kalkulatorze, mój pokazuje prawidłowo, ale to nie jest jeszcze właściwa metoda, ma właściwą nazwę, ale jeszcze nie liczy tego co chcemy, niemniej spieszę z wyjaśnieniem co tu się dzieje
tworzymy sobie dwie zmienne (z racji miejsca są one lokalne dla funkcji)

mamy pętlę nieskończoną, która przerywana jest warunkiem przekroczenie ustalonej wartości, pętla sumuje wartości, dopóki nie zostanie przerwana, a po zakończeniu zwraca sumę

teraz zamiast zwykłego sumowania zróbmy, by liczyło dla ciągu Fibonacciego

potrzebujemy zatem wiedzieć jak się go generuje (jest w linku z Wikipedii), w skrócie mamy dane dwie pierwsze liczby tego ciągu (obowiązkowe) i później dodajemy ostatnie znane dwie, by stworzyć kolejną

czyli skoro mamy dane 1 i 2, to następna jest 3 (suma dwóch ostatnich znanych)

teraz mamy 1,2,3 to następna to 5 (znów suma dwóch ostatnich znanych (2 i 3)

teraz mamy 1,2,3,5 to sumujemy 3 i 5 co daje wynik 8

następnie mamy 1,2,3,5,8 to kolejna jest 5+8 czyli 13

czyli w kodzie potrzebuje przechować sobie informacje o dwóch ostatnich, nazwiemy je n1 i n2

```python
def fibonacci(max_value):
    n1 = 1
    n2 = 2
    sum = n1 + n2
    while True:
        new = n1 + n2
        if new > max_value:
            break
        sum = sum + new  # lub krócej "sum += new"
        n1 = n2
        n2 = new
    return sum

print(fibonacci(3))
print(fibonacci(10))
print(fibonacci(100))
```
```
6
19
231
```

gdyby porównać te kody obok siebie, to widać, że zmianie uległy tylko wiersze gdzie było i a zastąpiły je wiersze odpowiedzialne za liczenie wspomnianych n1 i n2 czyli naszej umownej ostatniej i przedostatniej znanej liczby

pętla znów przerywa swoje działanie jeśli wartość liczby przekroczy tę zadaną

no to teraz ktoś powie, no łatwo teraz dodać wywołanie print(fibonacci(4000000)) i mamy zadanko z głowy, a ja mówię hold your horses

suma miała być tylko dla liczb parzystych (even in inglisz), no to żeby być kwita (tak wiem, potrzeba sporo wody, żeby przepić ten suchar) to lecimy

teraz trzeba sobie przypomnieć z podstawówki, co to znaczy, że liczba jest parzysta, a raczej definicję, że liczba jeśli dzieli się na dwa bez reszty to jest parzysta

w Pythonie zrealizujemy to metodą
```python
def is_even(number):
    return number % 2 == 0
```
funkcja ta (wcześniej powiedziałem "metoda") zwraca True dla parzystych i False dla nieparzystych

dla bardziej zaawansowanych wytłumaczę się przy okazji dlaczego "mieszam" funkcja/metoda, bo w Pythonie tak na prawdę prawie wszystko jest obiektem, więc aktualnie wykonywany kod to moduł (obiekt) znajdujacy się pod nazwą `__name__` i w jego obrębie wykonujemy kod, więc można do napisanej wcześniej metody sięgnąć za pomocą inspekcji metodą `getmembers` dla tego modułu

ok, do rzeczy, połączmy kropki... znaczy kod:
```python
def is_even(number):
    return number % 2 == 0

def fibonacci(max_value):
    n1 = 1
    n2 = 2
    sum = n2
    while True:
        new = n1 + n2
        if new > max_value:
            break
        if is_even(new):
            sum = sum + new  # lub krócej "sum += new"
        n1 = n2
        n2 = new
    return sum

print(fibonacci(4000000))
```

wynik powinien wyjść jak w **dropdown** na początku tego wątku

łączac kod musiałem dokonać drobnej modyfikacji wiersza sum = n1 + n2 na  sum = n2 jako że teraz chcemy mieć same parzyste i w pierwotnej wersji suma zawierała by cyfrę 1, który jest w tym wypadku nieprawidłowa

jednak przy ominięciu tego niuansu łatwo wykryć niedopatrzenie, bo wynik da zawsze liczbę nieparzystą (wiele parzystych +1) a musi być parzysty skoro powinniśmy dodawać same parzyste

no i oczywiście zgodnie z tym co napisałem ktoś może pokusić się o zrobienie "zadania domowego" czyli rozwiązać to zadanie, ale liczyć ciąg Fibonacciego w postaci rekurencyjnej i ewentualnie napisać generator
